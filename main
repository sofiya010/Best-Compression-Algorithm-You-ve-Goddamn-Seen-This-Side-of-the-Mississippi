import os
import struct
import numpy as np
from PIL import Image

from colorConversion import rgb_to_ycbcr_image, ycbcr_to_rgb_image
from entropyEncoding import zigzag_scan, inverse_zigzag_scan, rle_encode, rle_decode
from twoDDCT import (
    blockify,
    unblockify,
    dct_2d,
    idct_2d
)
from quantization import (
    quantize_block,
    dequantize_block,
    STANDARD_LUMA_Q,
    STANDARD_CHROMA_Q,
)

# JPEG-style constants
BLOCK_SIZE = 8                     # 8×8 DCT blocks
HEADER_MAGIC = b"JPCS"             # file signature
HEADER_VERSION = 2                 # version bump whenever format changes


# Load an image from disk, always convert to RGB
def load_image(path: str) -> Image.Image:
    img = Image.open(path).convert("RGB")
    return img


# Helper to save a PIL image
def save_image(img: Image.Image, path: str) -> None:
    img.save(path)


# Write compressed data to custom .jpc binary file
def save_compressed_to_file(compressed: dict, path: str) -> None:
    width = compressed["width"]
    height = compressed["height"]
    block_size = compressed["block_size"]

    y_blocks = compressed["y_blocks"]
    cb_blocks = compressed["cb_blocks"]
    cr_blocks = compressed["cr_blocks"]

    with open(path, "wb") as f:
        # Header (magic, version, sizes)
        f.write(HEADER_MAGIC)
        f.write(struct.pack(">B", HEADER_VERSION))
        f.write(struct.pack(">II", width, height))
        f.write(struct.pack(">B", block_size))
        f.write(struct.pack(">III", len(y_blocks), len(cb_blocks), len(cr_blocks)))

        # Writes a list of RLE-coded blocks for a single channel
        def write_channel(blocks):
            for rle_block in blocks:
                # First write how many (zero,value) pairs this block holds
                pair_count = len(rle_block)
                f.write(struct.pack(">H", pair_count))

                # Write each RLE pair
                for zeros, value in rle_block:
                    f.write(struct.pack(">Bh", zeros, value))

        write_channel(y_blocks)
        write_channel(cb_blocks)
        write_channel(cr_blocks)


# Read a .jpc file back into a Python dict
def load_compressed_from_file(path: str) -> dict:
    with open(path, "rb") as f:
        # Validate magic + version
        magic = f.read(4)
        if magic != HEADER_MAGIC:
            raise ValueError("Not a JPCS file")

        version = struct.unpack(">B", f.read(1))[0]
        if version != HEADER_VERSION:
            raise ValueError(f"Unsupported version: {version}")

        # Basic metadata
        width, height = struct.unpack(">II", f.read(8))
        block_size = struct.unpack(">B", f.read(1))[0]
        y_count, cb_count, cr_count = struct.unpack(">III", f.read(12))

        # Read all blocks for a channel
        def read_channel(block_count):
            blocks = []
            for _ in range(block_count):
                pair_count = struct.unpack(">H", f.read(2))[0]
                rle_block = []
                for _ in range(pair_count):
                    zeros, value = struct.unpack(">Bh", f.read(3))
                    rle_block.append((zeros, value))
                blocks.append(rle_block)
            return blocks

        y_blocks = read_channel(y_count)
        cb_blocks = read_channel(cb_count)
        cr_blocks = read_channel(cr_count)

    return {
        "width": width,
        "height": height,
        "block_size": block_size,
        "y_blocks": y_blocks,
        "cb_blocks": cb_blocks,
        "cr_blocks": cr_blocks,
    }


# Compress a single Y, Cb, or Cr channel
def _compress_channel(channel, q_matrix):
    """
    Channel compression pipeline:
      Y/Cb/Cr array → 8×8 blocks → DCT → quantize → zigzag → RLE.
    """
    # Ensure we have a float32 NumPy array
    channel = np.asarray(channel, dtype=np.float32)

    blocks = blockify(channel, BLOCK_SIZE)
    compressed_blocks = []

    for block in blocks:
        dct_block = dct_2d(block)                          # frequency transform
        q_block = quantize_block(dct_block, q_matrix)      # lossy quantization
        zz = zigzag_scan(q_block)                          # reorder for RLE
        rle = rle_encode(zz)                               # compress zero runs
        compressed_blocks.append(rle)

    return compressed_blocks


# Compress the entire RGB image (really YCbCr)
def compress_image(img: Image.Image):
    width, height = img.size

    # Convert RGB → Y, Cb, Cr (luma + two chroma channels)
    y_channel, cb_channel, cr_channel = rgb_to_ycbcr_image(img)

    # Compress each channel with its appropriate quantization table
    y_blocks = _compress_channel(y_channel, STANDARD_LUMA_Q)
    cb_blocks = _compress_channel(cb_channel, STANDARD_CHROMA_Q)
    cr_blocks = _compress_channel(cr_channel, STANDARD_CHROMA_Q)

    return {
        "width": width,
        "height": height,
        "block_size": BLOCK_SIZE,
        "y_blocks": y_blocks,
        "cb_blocks": cb_blocks,
        "cr_blocks": cr_blocks,
    }


# Reverse channel compression (for viewer)
def _decompress_channel(blocks_rle, q_matrix, width, height, block_size):
    reconstructed_blocks = []

    for rle_block in blocks_rle:
        zz = rle_decode(rle_block, total_length=64)              # undo RLE
        q_block = inverse_zigzag_scan(zz, block_size)            # undo zigzag
        dct_block = dequantize_block(q_block, q_matrix)          # undo quantization
        arr = np.array(dct_block, dtype=np.float32)
        spatial_block = idct_2d(arr)                             # inverse DCT
        reconstructed_blocks.append(spatial_block)

    # Stitch blocks back into a 2D image
    return unblockify(reconstructed_blocks, height, width, block_size)


# Full decompression (viewer only)
def decompress_image(compressed: dict) -> Image.Image:
    width = compressed["width"]
    height = compressed["height"]
    block_size = compressed["block_size"]

    y_chan = _decompress_channel(compressed["y_blocks"], STANDARD_LUMA_Q, width, height, block_size)
    cb_chan = _decompress_channel(compressed["cb_blocks"], STANDARD_CHROMA_Q, width, height, block_size)
    cr_chan = _decompress_channel(compressed["cr_blocks"], STANDARD_CHROMA_Q, width, height, block_size)

    # Convert back to RGB
    return ycbcr_to_rgb_image(y_chan, cb_chan, cr_chan)


def main():
    input_path = "input.bmp"
    compressed_path = "compressed.jpc"

    img = load_image(input_path)

    # Resize large images so compression is faster for testing
    img = img.resize((800, 533))
    print("Loaded image:", img.size)
    width, height = img.size

    # Compress and write result to .jpc
    compressed = compress_image(img)
    print("Compression produced", len(compressed["y_blocks"]), "Y blocks")

    save_compressed_to_file(compressed, compressed_path)
    print("Saved compressed file to", compressed_path)

    # --- Size comparisons ---
    raw_rgb_bytes = width * height * 3
    original_size = os.path.getsize(input_path)
    compressed_size = os.path.getsize(compressed_path)

    print("\nSize comparison (bytes):")
    print(f"  Raw RGB (width*height*3): {raw_rgb_bytes}")
    print(f"  Original input file:       {original_size}")
    print(f"  Custom JPC file:           {compressed_size}")

    # Compression ratios
    raw_ratio = raw_rgb_bytes / compressed_size
    file_ratio = original_size / compressed_size

    print("\nCompression ratios:")
    print(f"  Raw RGB  : Custom JPC ≈ {raw_ratio:.2f}:1")
    print(f"  PNG file : Custom JPC ≈ {file_ratio:.2f}:1")


if __name__ == "__main__":
    main()
